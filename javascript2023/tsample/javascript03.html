<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 배우기 😳</title>

    <link rel="stylesheet" href="../../assets/css/fonts.css">
    <link rel="stylesheet" href="../../assets/css/reset.css">
    <link rel="stylesheet" href="../../assets/css/webs.css">

    <link rel="shortcut icon" href="../../assets/ico/favicon.png">
    <link rel="apple-touch-icon-precomposed" href="../../assets/ico/favicon.png">
    <link rel="icon" href="../../assets/ico/favicon.png">
    <link rel="icon" href="../../assets/ico/favicon.png" sizes="48x48">
    <link rel="icon" href="../../assets/ico/favicon.png" sizes="64x64">
    <link rel="icon" href="../../assets/ico/favicon.png" sizes="128x128">

    <meta name="acthor" content="웹스토리보이">
    <meta name="description" content="한가지 사이트를 다양한 프레임워크를 통해 만들어 보는 포트폴리오 사이트입니다.">
    <meta name="keywords" content="포트폴리오, portfolio, 리액트, react.js, 뷰, vue.js, 넥스트, next.js, 웹스토리보이, webstoryboy">
    <meta name="robots" content="all">
</head>
<body>

    <div id="skip">
        <a href="#header">헤더 영역 바로가기</a>
        <a href="#main">컨텐츠 영역 바로가기</a>
        <a href="#footer">푸터 영역 바로가기</a>
    </div>
    <!-- //skip -->

    <header id="header">
        <div class="header__inner">
            <div class="left"> 
                <a href="../index.html" class="star"><span class="ir">메인으로</span></a>
            </div>
            <h1>
                <a href="../index.html">WEBSTORYBOY</a>
            </h1>
            <div class="right">
                <ul>
                    <li><a href="#">검색</a></li>
                </ul>
            </div>
            <nav class="nav">
                <ul>
                    <li><a href="#"><span>레퍼런스</span></a></li>
                    <li><a href="#"><span>튜토리얼</span></a></li>
                    <li><a href="#"><span>게시판</span></a></li>
                    <li><a href="#"><span>블로그</span></a></li>
                </ul>
            </nav>
        </div>
    </header>
    <!-- //header -->

    <main id="main">
        <section id="blog" class="nanumSquareNeo">
            <div class="blog__title">
                <span class="cate">Tutorial/JavaScript</span>
                <h1 class="title">자바스크립트 배우기</h1>
                <div class="meta">
                    <span class="author">by @webs</span>
                    <span class="date">2023. 08. 01.</span>
                </div>
            </div>
            <div class="blog__inner container">
                <div id="youtube" class="blog__contents__intro">
                    <div class="desc rightX">
                        <div class="left">
                            <span class="num">03</span>
                            <div class="title">자바스크립트 배우기 : 데이터 실행하기</div>
                            <span class="difficulty">난이도 <span>중간</span></span>
                        </div>
                        <div class="right">
                            <div class="btn">소스 다운로드</div>
                            <a href="https://port2023-next.netlify.app" target="_blank" class="sampleBtn">완성 화면</a>
                            <a href="https://github.com/webstoryboy/port2023-next" target="_blank" class="sampleBtn">완성 코드</a>
                            <a href="https://www.youtube.com/playlist?list=PL4UVBBIc6giLabEb4ygOmKDWCnsSKq2uP" target="_blank" class="sampleBtn">영상 보기</a>
                        </div>
                    </div>
                </div>
                <!-- //blog__contents__intro -->

                <div class="blog__contents tutorial">
                    <h2>소개</h2>
                    <p>
                        안녕하세요! 웹스토리보이입니다.
                        이 강의는 자바스크립트 초급부터 고급까지 아우르는 자바스크립트 핵심 개념을 다루는 기본서 강의입니다. 
                        일반적인 자바스크립트 강의와는 목표와 방식이 다릅니다. 
                        여기에서는 자바스크립트를 어떻게 단순하게 이해하고, 현실적으로 활용할 수 있는지를 고려하여 만들어진 내용입니다.
                    </p>
                    <p>
                        자바스크립트를 배우면서 때로는 이해하기 어려운 부분이나 무엇을 해야 하는지 혼란스러운 부분이 있을 수 있습니다. 
                        그런 어려움을 극복하고 불필요한 시간 낭비를 줄이기 위해 이 강의는 차별화된 접근 방식을 채택하였습니다. 
                        또한, 개인적으로도 어려움을 겪었던 부분들을 고려하여 설명하였습니다.
                    </p>
                    <p>
                        이 강의의 주요 목표는 자바스크립트를 학습하면서, 이론 뿐만 아니라 실제로 어떻게 활용할 수 있는지를 강조하는 것입니다. 
                        이를 위해 강의는 크게 네 가지 주요 영역으로 구성되었습니다. 
                        데이터 저장, 데이터 불러오기, 데이터 실행, 그리고 데이터 제어입니다. 
                        이렇게 체계적으로 기초를 다지고 나서 실제 상황에 유용하게 활용할 수 있는 실용적인 예제를 다룰 것입니다.
                        이를 통해 프로그래밍 실력을 크게 향상시킬 수 있는 기회를 가지게 될 것입니다. 
                        이 강의를 통해 자바스크립트의 세계에 더욱 가깝게 다가갈 수 있길 바랍니다.
                    </p>

                    <hr>

                    <h3>인덱스</h3>
                    <div class="index3">
                        <ul>
                            <li>1. 데이터 저장하기
                                <ul>
                                    <li><a href="#v01">01. 변수 : 데이터 저장</a></li>
                                    <li><a href="#v02">02. 변수 : 데이터 저장 + 데이터 변경</a></li>
                                    <li><a href="#v03">03. 변수 : 데이터 저장 + 데이터 변경 + 데이터 추가</a></li>
                                    <li><a href="#v04">04. 상수 : 데이터 저장 + 데이터 변경(X)</a></li>
                                    <li><a href="#v05">05. 배열 : 데이터 저장(여러개) : 표현방법1 : 배열 선언 </a></li>
                                    <li><a href="#v06">06. 배열 : 데이터 저장(여러개) : 표현방법2 : 배열 선언과 동시에 초깃값 설정</a></li>
                                    <li><a href="#v07">07. 배열 : 데이터 저장(여러개) : 표현방법3 : 리터럴 방식으로 배열 선언</a></li>
                                    <li><a href="#v08">08. 배열 : 데이터 저장(여러개) : 표현방법4 : push() 메서드를 이용한 방법</a></li>
                                    <li><a href="#v09">09. 배열 : 데이터 저장(여러개) : 표현방법5 : 리터럴 방식으로 배열 선언과 동시에 초깃값 설정</a></li>
                                    <li><a href="#v10">10. 배열 : 데이터 저장(여러개) : 표현방법6 : 다차원 배열</a></li>
                                    <li><a href="#v11">11. 배열 : 데이터 저장(여러개) : 표현방법7 : 배열 구조 분해 할당</a></li>
                                    <li><a href="#v12">12. 배열 : 데이터 저장(여러개) : 표현방법8 : 배열 펼침연산자</a></li>
                                    <li><a href="#v13">13. 객체 : 데이터 저장(키와값) : 표현방법1 : 객체 선언 후 배열 방식으로 데이터 입력</a></li>
                                    <li><a href="#v14">14. 객체 : 데이터 저장(키와값) : 표현방법2 : 객체 선언 후 객체 방식으로 데이터 입력</a></li>
                                    <li><a href="#v15">15. 객체 : 데이터 저장(키와값) : 표현방법3 : 리터럴 방식으로 객체 선언</a></li>
                                    <li><a href="#v16">16. 객체 : 데이터 저장(키와값) : 표현방법4 : 리터럴 방식으로 객체 선언과 동시에 초깃값을 설정</a></li>
                                    <li><a href="#v17">17. 객체 : 데이터 저장(키와값) : 표현방법5 : 배열안에 객체가 있는 방식</a></li>
                                    <li><a href="#v18">18. 객체 : 데이터 저장(키와값) : 표현방법6 : 객체안에 배열이 있는 방식</a></li>
                                    <li><a href="#v19">19. 객체 : 데이터 저장(키와값) : 표현방법7 : 객체안에 객체가 있는 방식</a></li>
                                    <li><a href="#v20">20. 객체 : 데이터 저장(키와값) : 표현방법8 : 객체 + 함수가 있는 방식</a></li>
                                    <li><a href="#v21">21. 객체 : 데이터 저장(키와값) : 표현방법9 : 객체 구조 분해 할당</a></li>
                                    <li><a href="#v22">22. 객체 : 데이터 저장(키와값) : 표현방법10 : 객체 펼침연산자</a></li>
                                    <li><a href="#v23">23. 파일 : 데이터 교환(JSON) </a></li>
                                </ul>
                            </li>
                            <li>2. 데이터 불러오기
                                <ul>
                                    <li><a href="#a01">01. 변수 : 데이터 불러오기</a></li>
                                    <li><a href="#a02">02. 상수 : 데이터 불러오기</a></li>
                                    <li><a href="#a03">03. 배열 : 데이터 불러오기</a></li>
                                    <li><a href="#a04">04. 배열 : 데이터 불러오기 : 갯수</a></li>
                                    <li><a href="#a05">05. 배열 : 데이터 불러오기 : for()</a></li>
                                    <li><a href="#a06">06. 배열 : 데이터 불러오기 : forEach()</a></li>
                                    <li><a href="#a07">07. 배열 : 데이터 불러오기 : for of</a></li>
                                    <li><a href="#a08">08. 배열 : 데이터 불러오기 : for in</a></li>
                                    <li><a href="#a09">09. 배열 : 데이터 불러오기 : map()</a></li>
                                    <li><a href="#a10">10. 배열 : 데이터 불러오기 : filter()</a></li>
                                    <li><a href="#a11">11. 배열 : 데이터 불러오기 : 배열 펄침 연산자</a></li>
                                    <li><a href="#a12">12. 배열 : 데이터 불러오기 : 배열 구조 분해 할당</a></li>
                                    <li><a href="#a13">13. 객체 : 데이터 불러오기 : 기본</a></li>
                                    <li><a href="#a14">14. 객체 : 데이터 불러오기 : Object.keys()</a></li>
                                    <li><a href="#a15">15. 객체 : 데이터 불러오기 : Object.values()</a></li>
                                    <li><a href="#a16">16. 객체 : 데이터 불러오기 : Object.entries()</a></li>
                                    <li><a href="#a17">17. 객체 : 데이터 불러오기 : Object.assign()</a></li>
                                    <li><a href="#a18">18. 객체 : 데이터 불러오기 : hasOwnProperty()</a></li>
                                    <li><a href="#a19">19. 객체 : 데이터 불러오기 : for in</a></li>
                                    <li><a href="#a20">20. 객체 : 데이터 불러오기 : 객체 펼침 연산자</a></li>
                                    <li><a href="#a21">21. 객체 : 데이터 불러오기 : 객체 구조 분해 할당</a></li>
                                    <li><a href="#a22">22. 파일 : 서버 데이터 불러오기 : XMLHttpRequest</a></li>
                                    <li><a href="#a23">23. 파일 : 서버 데이터 불러오기 : fetch API</a></li>
                                </ul>
                            </li>
                            <li>3. 데이터 실행하기
                                <ul>
                                    <li><a href="#w01">01. 함수 : 선언적 함수</a></li>
                                    <li><a href="#w02">02. 함수 : 익명 함수</a></li>
                                    <li><a href="#w03">03. 함수 : 매개변수 함수</a></li>
                                    <li><a href="#w04">04. 함수 : 리턴값 함수</a></li>
                                    <li><a href="#w05">05. 함수 : 매개변수 + 리턴값 함수</a></li>
                                    <li><a href="#w06">06. 화살표 함수 : 선언적 함수</a></li>
                                    <li><a href="#w07">07. 화살표 함수 : 익명 함수</a></li>
                                    <li><a href="#w08">08. 화살표 함수 : 매개변수 함수</a></li>
                                    <li><a href="#w09">09. 화살표 함수 : 리턴값 함수</a></li>
                                    <li><a href="#w10">10. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값 함수</a></li>
                                    <li><a href="#w11">11. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                                    <li><a href="#w12">12. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                                    <li><a href="#w13">13. 함수 유형 : 함수와 배열 이용한 형태</a></li>
                                    <li><a href="#w14">14. 함수 유형 : 함수와 객체 이용한 형태</a></li>
                                    <li><a href="#w15">15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</a></li>
                                    <li><a href="#w16">16. 함수 유형 : 객체 안에 함수를 이용한 형태</a></li>
                                    <li><a href="#w17">17. 함수 유형 : 객체 생성자 함수</a></li>
                                    <li><a href="#w18">18. 함수 유형 : 프로토타입 함수</a></li>
                                    <li><a href="#w19">19. 함수 유형 : 객체 리터럴 함수</a></li>
                                    <li><a href="#w20">20. 함수 : 즉시실행 함수</a></li>
                                    <li><a href="#w21">21. 함수 : 파라미터 함수</a></li>
                                    <li><a href="#w22">22. 함수 : 재귀 함수</a></li>
                                    <li><a href="#w23">23. 함수 : 콜백 함수</a></li>
                                    <li><a href="#w24">24. 함수 : 비동기 방식 : 콜백 함수</a></li>
                                    <li><a href="#w25">25. 함수 : 비동기 방식 : 프로미스</a></li>
                                    <li><a href="#w26">26. 함수 : 비동기 방식 : async/await</a></li>
                                    <li><a href="#w27">27. 함수 : 중첩 함수</a></li>
                                    <li><a href="#w28">28. 함수 : 클로저</a></li>
                                    <li><a href="#w29">29. 클래스 : 기본</a></li>
                                    <li><a href="#w30">30. 클래스 : 상속</a></li>
                                </ul>
                            </li>
                            <li>4. 데이터 제어하기</li>
                        </ul>
                    </div>

                    
                    
                    <h3>3. 데이터 실행하기</h3>
                    <div id="w01">
                        <h4>01. 함수 : 선언적 함수</h4>
                        <p>
                            선언적 함수(Declaration function)는 function 키워드를 사용하여 정의된 함수입니다.
                        </p>
<pre><code class="language-js">{
        function func(){
                console.log("1. 함수가 실행되었습니다.");
        }
        func();

        // 1. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                <code>func</code>인 함수를 정의하고, 함수를 호출하여 함수 내부에서 변수 <code>x</code>를 선언하고 값을 출력하는 간단한 예제입니다.
                            </p>
                            <ul class="list">
                                <li><i>function func() { ... }</i> → 이 부분은 func라는 이름의 함수를 정의합니다. 함수 정의는 function 키워드로 시작하며, 함수 이름(func)을 지정한 후 괄호 ()를 사용하여 함수의 매개변수를 정의할 수 있습니다. 이 예제에서는 매개변수를 사용하지 않는 간단한 함수를 정의하고 있습니다. 함수의 내용은 중괄호 {} 안에 위치하며, 이 부분에는 함수가 실행될 때 수행할 코드를 작성합니다.</li>
                                <li><i>console.log("1. 함수가 실행되었습니다.");</i> → 이 부분은 함수 내부에서 실행되는 코드입니다. console.log 함수를 사용하여 콘솔에 "1. 함수가 실행되었습니다."라는 문자열을 출력하고 있습니다. 이 코드는 함수가 호출되었을 때 실행됩니다.</li>
                                <li><i>func();</i> → 이 부분은 func라는 함수를 호출하는 코드입니다. 함수를 호출할 때 함수 이름 뒤에 괄호 ()를 사용하고, 필요한 경우 함수에 전달할 인자(매개변수)를 괄호 안에 넣어줄 수 있습니다. 이 예제에서는 매개변수를 사용하지 않으므로 괄호 안이 비어있습니다. 함수 호출은 함수 내의 코드를 실행시키는 역할을 합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w02" class="mt80">
                        <h4>02. 함수 : 익명 함수</h4>
                        <p>
                            익명 함수(Anonymous function)는 이름이 없는 함수입니다. 
                            함수를 변수에 할당하여 사용하는 것은 함수를 다른 함수의 인자로 전달하거나, 함수를 반환하는 고급적인 활용도 가능하게 해줍니다.
                        </p>
<pre><code class="language-js">{
        const func = function(){
                console.log("2. 함수가 실행되었습니다.");
        }
        func();

        // 2. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                익명 함수(anonymous function)를 변수에 할당하고 그 함수를 호출하는 예제입니다.
                                이와 같이 함수를 변수에 할당하면 함수를 다루거나 전달하기가 편리해집니다.
                            </p>
                            <ul class="list">
                                <li><i>const func = function() { ... }</i> → 이 부분은 func라는 이름의 상수 변수를 선언하고, 이 변수에 익명 함수를 할당합니다. 익명 함수란 이름이 없는 함수로, 함수를 변수에 할당하여 사용할 때 주로 활용됩니다. 이 예제에서는 함수를 선언하면서 function 키워드 대신 function()과 같은 형태로 함수를 정의하고 있습니다.</li>
                                <li><i>console.log("2. 함수가 실행되었습니다.");</i> → 이 부분은 익명 함수 내부에서 실행되는 코드입니다. 익명 함수가 호출되면 이 코드가 실행되어 콘솔에 "2. 함수가 실행되었습니다."라는 문자열을 출력합니다.</li>
                                <li><i>func();</i> → 이 부분은 func라는 변수에 할당된 함수를 호출하는 코드입니다. 변수 func에는 익명 함수가 할당되어 있으므로 이 함수를 호출하기 위해서 func()와 같이 괄호를 사용합니다. 함수 호출은 함수 내의 코드를 실행시킵니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w03" class="mt80">
                        <h4>03. 함수 : 매개변수 함수</h4>
                        <p>
                            매개변수가 있는 함수는 매개변수를 통해 함수 내부로 값을 전달하여 동적인 처리를 할 수 있습니다.
                        </p>
<pre><code class="language-js">{
        // 01 선언적 함수를 이용한 매개변수
        function func(str){
                console.log(str);
        }
        func("3. 함수가 실행되었습니다.");

        // 02 익명 함수를 이용한 매개변수
        const func1 = function(str){
                console.log(str);
        }
        func1("3. 함수가 실행되었습니다.");

        // 3. 함수가 실행되었습니다.
        // 3. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                선언적 함수와 익명 함수를 사용하여 문자열을 콘솔에 출력하는 예제입니다. 함수를 정의하고 호출하는 방법을 보여줍니다.
                            </p>
                            <ul class="list">
                                <li>01 → func"라는 이름의 선언적 함수를 정의하고 있습니다. 함수 이름을 가지고 있으며 함수 내부에서 console.log를 사용하여 전달된 문자열 str을 콘솔에 출력합니다. 그런 다음, "func" 함수를 호출하고 문자열 "3. 함수가 실행되었습니다."을 인자로 전달하여 실행합니다.</li>
                                <li>02 → 익명 함수를 생성하고 "func1"이라는 상수 변수에 할당합니다. 이 함수도 전달된 문자열 str을 콘솔에 출력하는 역할을 합니다</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w04" class="mt80">
                        <h4>04. 함수 : 리턴값 함수</h4>
                        <p>
                            리턴값 함수는 함수가 실행된 후에 반환하는 값을 말합니다.
                        </p>
<pre><code class="language-js">{
        // 01 선언적 함수를 이용한 리턴값 함수
        function func(){
                return "4. 함수가 실행되었습니다.";
        }
        console.log(func());

        // 02 익명 함수를 이용한 리턴값 함수
        const func1 = function(){
                return "4. 함수가 실행되었습니다.";
        }
        console.log(func1());

        // 4. 함수가 실행되었습니다.
        // 4. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                리턴값을 이용한 함수를 두 가지 유형으로 보여주는 예제입니다.
                            </p>
                            <ul class="list">
                                <li>01 → "func"라는 이름의 선언적 함수를 정의하고 있습니다. 이 함수는 매개변수를 받지 않고, 문자열 "4. 함수가 실행되었습니다."를 반환합니다. 그런 다음 "func" 함수를 호출하고 그 반환값을 console.log를 사용하여 콘솔에 출력합니다.</li>
                                <li>02 → 익명 함수를 생성하고 "func1"이라는 상수 변수에 할당하고 있습니다. 익명 함수는 이름이 없는 함수로, 함수를 변수에 할당하여 사용합니다. "func1" 함수도 매개변수를 받지 않으며, 함수 내부에서는 "4. 함수가 실행되었습니다."라는 문자열을 반환합니다. 그런 다음 "func1" 함수를 호출하고 반환된 값을 console.log를 사용하여 콘솔에 출력합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w05" class="mt80">
                        <h4>05. 함수 : 매개변수 + 리턴값 함수</h4>
                        <p>
                            매개변수와 리턴값이 합쳐진 형태의 예시입니다.
                        </p>
<pre><code class="language-js">{
        // 01 선언적 함수를 이용한 매개변수 + 리턴값 함수
        function func(str){
                return str;
        }
        console.log(func("5. 함수가 실행되었습니다."));

        // 02 익명 함수를 이용한 매개변수 + 리턴값 함수
        const func1 = function(str){
                return str;
        }
        const num1 = func1("5. 함수가 실행되었습니다.");
        console.log(num1);

        // 5. 함수가 실행되었습니다.
        // 5. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                두 가지 함수를 사용하여 문자열을 반환하고, 반환된 값을 변수에 저장하고 콘솔에 출력하는 간단한 예제입니다. 함수는 값을 반환할 수 있으며, 반환된 값을 변수에 저장하거나 직접 사용할 수 있습니다.
                            </p>
                            <ul class="list">
                                <li>01 → "func"라는 이름의 선언적 함수를 정의하고 있습니다. 이 함수는 "str"이라는 매개변수를 받아와서 받은 문자열 "str"을 반환합니다. 그런 다음 "func" 함수를 호출하고 문자열 "5. 함수가 실행되었습니다."를 인자로 전달하여 실행합니다. 그 결과를 console.log를 사용하여 콘솔에 출력합니다.</li>
                                <li>02 → 익명 함수를 생성하고 "func1"이라는 상수 변수에 할당하고 있습니다. 익명 함수도 매개변수 str를 받아 받은 문자열 str을 반환합니다. 그런 다음 "func1" 함수를 호출하고 반환된 값을 num1 변수에 저장합니다. 마지막으로 num1 변수 값을 console.log를 사용하여 콘솔에 출력합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w06" class="mt80">
                        <h4>06. 화살표 함수 : 선언적 함수</h4>
                        <p>
                            선언적 함수를 화살표 함수로 변경하는 예제입니다. 
                        </p>
<pre><code class="language-js">{
        func = () => {
                console.log("6. 함수가 실행되었습니다.");
        }
        func();

        // 6. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이 코드는 간단한 화살표 함수를 사용하여 함수를 정의하고 호출하는 예제입니다. 함수를 호출할 때 func()와 같이 호출하면 함수 내의 코드가 실행되어 원하는 동작을 수행합니다.
                            </p>
                            <ul class="list">
                                <li>func라는 변수에 화살표 함수를 정의합니다. 화살표 함수는 매개변수가 없고, 실행될 때 "6. 함수가 실행되었습니다."라는 문자열을 콘솔에 출력하는 함수를 정의합니다.</li>
                                <li>func()를 호출합니다. 정의한 화살표 함수가 실행되며, 결과적으로 "6. 함수가 실행되었습니다."라는 메시지가 콘솔에 출력됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w07" class="mt80">
                        <h4>07. 화살표 함수 : 익명 함수</h4>
                        <p>
                            익명 함수를 화살표 함수로 변경하는 예제입니다. 
                        </p>
<pre><code class="language-js">{
        const func = () => {
                console.log("7. 함수가 실행되었습니다.");
        };
        func();

        // 7. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이 코드는 간단한 화살표 함수를 사용하여 함수를 정의하고 호출하는 예제입니다. 함수를 호출할 때 func()와 같이 호출하면 함수 내의 코드가 실행되어 원하는 동작을 수행합니다.
                            </p>
                            <ul class="list">
                                <li>func라는 변수에 화살표 함수를 정의합니다. 화살표 함수는 매개변수가 없고, 실행될 때 "7. 함수가 실행되었습니다."라는 문자열을 콘솔에 출력하는 함수를 정의합니다.</li>
                                <li>func()를 호출합니다. 정의한 화살표 함수가 실행되며, 결과적으로 "7. 함수가 실행되었습니다."라는 메시지가 콘솔에 출력됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w08" class="mt80">
                        <h4>08. 화살표 함수 : 매개변수 함수</h4>
                        <p>
                            매개변수가 있는 있는 함수(선언적 함수, 익명 함수)를 화살표 함수로 변경하는 예제입니다.
                        </p>
<pre><code class="language-js">{
        // 01 선언적 함수 => 화살표 함수
        func = (str) => {
                console.log(str);
        }
        func("8. 함수가 실행되었습니다.");

        // 02 익명 함수 => 화살표 함수
        const func1 = (str) => {
                console.log(str);
        }
        func1("8. 함수가 실행되었습니다.");

        // 8. 함수가 실행되었습니다.
        // 8. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이 코드는 선언적 함수와 익명 함수를 화살표 함수로 변환한 예제입니다. 화살표 함수를 사용하면 코드가 더 간결해지고, 함수를 변수에 할당하여 사용할 때 편리합니다.
                            </p>
                            <ul class="list">
                                <li>01 → func라는 변수에 선언적 함수를 정의합니다. 이 함수는 str 매개변수를 받고, 받은 문자열을 콘솔에 출력합니다. 그런 다음, func("8. 함수가 실행되었습니다.");를 호출하여 함수를 실행합니다. 결과적으로 "8. 함수가 실행되었습니다."라는 문자열이 콘솔에 출력됩니다.</li>
                                <li>02 → func1라는 변수에 화살표 함수를 정의합니다. 이 화살표 함수는 str 매개변수를 받고, 받은 문자열을 콘솔에 출력합니다. 그런 다음, func1("8. 함수가 실행되었습니다.");를 호출하여 함수를 실행합니다. 결과적으로 또 다른 "8. 함수가 실행되었습니다."라는 문자열이 콘솔에 출력됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w09" class="mt80">
                        <h4>09. 화살표 함수 : 리턴값 함수</h4>
                        <p>
                            리턴값이 있는 있는 함수(선언적 함수, 익명 함수)를 화살표 함수로 변경하는 예제입니다.
                        </p>
<pre><code class="language-js">{
        // 01 선언적 함수 => 화살표 함수
        func1 = () => {
                return "9. 함수가 실행되었습니다.";
        }
        console.log(func1());

        // 02 익명 함수 => 화살표 함수
        const func2 = () => {
                return "9. 함수가 실행되었습니다.";
        }
        console.log(func2());

        // 9. 함수가 실행되었습니다.
        // 9. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이 코드는 선언적 함수와 익명 함수를 화살표 함수로 변환하고 호출하는 예제입니다. 화살표 함수를 사용하면 코드가 더 간결해지고 함수를 변수에 할당하여 사용할 때 편리합니다.
                            </p>
                            <ul class="list">
                                <li>01 → func1이라는 화살표 함수를 정의합니다. 화살표 함수는 매개변수가 없고, "9. 함수가 실행되었습니다."라는 문자열을 반환합니다. 그런 다음, console.log(func1());를 호출하여 함수를 실행하고 반환값을 콘솔에 출력합니다. 결과적으로 "9. 함수가 실행되었습니다."가 콘솔에 출력됩니다.</li>
                                <li>02 → func2라는 변수에 화살표 함수를 정의합니다. 화살표 함수는 매개변수가 없고, "9. 함수가 실행되었습니다."라는 문자열을 반환합니다. 그런 다음, console.log(func2());를 호출하여 함수를 실행하고 반환값을 콘솔에 출력합니다. 결과적으로 또 다른 "9. 함수가 실행되었습니다."가 콘솔에 출력됩니다</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w10" class="mt80">
                        <h4>10. 화살표 함수 : 매개변수 + 리턴값 함수</h4>
                        <p>
                            화살표 함수의 여러가지 형태와 약식 문법 예제입니다.
                        </p>
<pre><code class="language-js">{
        // 01 익명 함수 + 매개변수 + 리턴값 함수
        const func = (str) => {
                return str;
        }
        console.log(func("10. 함수가 실행되었습니다."));

        // 02 매개변수 한개일때 괄호 생략 가능
        const func2 = str => {
                return str;
        }
        console.log(func2("10. 함수가 실행되었습니다."));

        // 03 리턴 생략
        const func3 = str => str;
        
        console.log(func3("10. 함수가 실행되었습니다."));

        // 04 선언적 함수 (가독성X)
        func4 = str => str;
        
        console.log(func4("10. 함수가 실행되었습니다."));
}   
</code></pre>
                        <div class="sampleBasic">
                            <ul class="list">
                                <li><i>익명 함수 + 매개변수 + 리턴값 함수</i> → func에 익명 화살표 함수를 할당하고, 매개변수 x를 받아서 그 값을 반환하는 함수를 정의합니다. 이후 함수를 호출하여 매개변수로 100을 전달하고 반환값을 출력합니다.</li>
                                <li><i>매개변수 한개일때 괄호 생략 가능</i> → 매개변수가 하나일 경우에는 괄호를 생략할 수 있는 화살표 함수를 정의합니다. 이후 함수를 호출하여 매개변수로 200을 전달하고 반환값을 출력합니다.</li>
                                <li><i>리턴 생략</i> → 함수 내부에서 바로 값을 반환하는 경우에 리턴 키워드를 생략할 수 있는 화살표 함수를 정의합니다. 이후 함수를 호출하여 매개변수로 300을 전달하고 반환값을 출력합니다.</li>
                                <li><i>선언적 함수</i> → 화살표 함수를 선언적으로 변수에 할당하는 형태로 정의합니다. 이 방식은 코드 가독성을 떨어뜨릴 수 있습니다. 이후 함수를 호출하여 매개변수로 400을 전달하고 반환값을 출력합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w11" class="mt80">
                        <h4>11. 함수 유형 : 함수와 매개변수를 이용한 형태</h4>
                        <p>
                            함수와 매개변수를 이용한 형태의 함수 예제입니다.
                        </p>
<pre><code class="language-js">{
        function func(num, str){
                console.log(num + ". " + str);
                console.log(`${num}. ${str}`);
        }

        func(11, "함수가 실행되었습니다.");

        // 11. 함수가 실행되었습니다.
        // 11. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                함수를 정의하고 매개변수를 전달하고 호출하는 일반적인 함수의 예제입니다.
                            </p>
                            <ul class="list">
                                <li>func라는 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받으며, 받은 값들을 사용하여 두 가지 형태로 문자열을 콘솔에 출력합니다.</li>
                                <li>func(11, "함수가 실행되었습니다.");를 호출하여 함수를 실행합니다. 매개변수 num에는 11이 전달되고, 매개변수 str에는 "함수가 실행되었습니다."라는 문자열이 전달됩니다.</li>
                                <li>첫 번째 console.log는 문자열 연결 연산자(+)를 사용하여 문자열을 생성하고 출력하고, 두 번째 console.log는 템플릿 리터럴(${})을 사용하여 문자열을 생성하고 출력합니다. 결과적으로 두 가지 형태로 "11. 함수가 실행되었습니다."라는 문자열이 콘솔에 출력됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w12" class="mt80">
                        <h4>12. 함수 유형 : 함수와 변수를 이용한 형태</h4>
                        <p>
                            함수와 변수를 이용한 형태의 함수 예제입니다.
                        </p>
<pre><code class="language-js">{
        const num = 12;
        const str = "함수가 실행되었습니다.";

        function func(num, str){
                console.log(`${num}. ${str}`);
        }

        func(num, str);

        // 12. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이 함수는 저장된 변수 값을 매개변수로 전달하고 템플릿 리터럴을 사용하여 문자열로 결합하고 출력하는 예제입니다. 
                            </p>
                            <ul class="list">
                                <li><i>num과 str 변수</i> → num 변수에 12를, str 변수에 "함수가 실행되었습니다."라는 문자열을 할당합니다.</li>
                                <li><i>함수 정의</i> → func라는 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받으며, 템플릿 리터럴을 사용하여 매개변수 값을 문자열로 결합하여 콘솔에 출력합니다.</li>
                                <li><i>함수 호출</i> → func(num, str);를 호출하여 함수를 실행합니다. 전역 변수 num에 할당된 값 12와 전역 변수 str에 할당된 문자열 "함수가 실행되었습니다."를 함수에 전달합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w13" class="mt80">
                        <h4>13. 함수 유형 : 함수와 배열 이용한 형태</h4>
                        <p>
                            함수와 배열 이용한 형태의 함수 예제입니다.
                        </p>
<pre><code class="language-js">{
        const num = [13, 14];
        const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."];

        function func(num, str){
                console.log(`${num}. ${str}`);
        }

        func(num[0], str[0]);
        func(num[1], str[1]);

        // 13. 함수가 실행되었습니다.
        // 14. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                배열과 함수를 사용하여 값을 출력하는 예제입니다.
                            </p>
                            <ul class="list">
                                <li><i>num과 str 배열 정의</i> → num 배열에 [13, 14]를, str 배열에 ["함수가 실행되었습니다.", "함수가 실행되었습니다."]라는 문자열을 할당합니다.</li>
                                <li><i>함수 정의</i> → func라는 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받으며, 템플릿 리터럴을 사용하여 매개변수 값을 문자열로 결합하여 콘솔에 출력합니다.</li>
                                <li><i>함수 호출</i> → 두 번의 func 함수 호출을 합니다. 첫 번째 호출에서는 num[0]과 str[0]을 전달하고, 두 번째 호출에서는 num[1]과 str[1]을 전달합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w14" class="mt80">
                        <h4>14. 함수 유형 : 함수와 객체 이용한 형태</h4>
                        <p>
                            함수와 객체를 이용한 형태의 함수 예제입니다.
                        </p>
<pre><code class="language-js">{
        const info = {
                num : 15,
                str : "함수가 실행되었습니다."
        }
        function func(num, str){
                console.log(`${num}. ${str}`);
        }

        func(info.num, info.str);

        // 15. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                객체와 함수를 사용하여 값을 출력하는 예제입니다
                            </p>
                            <ul class="list">
                                <li><i>info 객체 정의</i> → info 객체를 정의합니다. 이 객체는 num 속성에 15를, str 속성에 "함수가 실행되었습니다."라는 문자열을 가지고 있습니다.</li>
                                <li><i>함수 정의</i> → func라는 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받으며, 템플릿 리터럴을 사용하여 매개변수 값을 문자열로 결합하여 콘솔에 출력합니다.</li>
                                <li><i>함수 호출</i> → func(info.num, info.str);를 호출하여 함수를 실행합니다. info.num은 객체 info의 num 속성의 값인 15를, info.str은 객체 info의 str 속성의 값인 "함수가 실행되었습니다."를 전달합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w15" class="mt80">
                        <h4>15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</h4>
                        <p>
                            함수와 객체 및 배열을 이용한 형태의 함수 예제입니다.
                        </p>
<pre><code class="language-js">{
        const info = [
                {num: 16, str: "함수가 실행되었습니다."},
                {num: 17, str: "함수가 실행되었습니다."},
        ];

        function func(num, str){
                console.log(`${num}. ${str}`);
        }

        func(info[0].num, info[0].str);
        func(info[1].num, info[1].str);

        // 16. 함수가 실행되었습니다.
        // 17. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                배열과 객체를 사용하여 값을 출력하는 예제입니다
                            </p>
                            <ul class="list">
                                <li><i>info 배열 정의</i> → info 배열을 정의합니다. 이 배열은 두 개의 객체를 요소로 가지고 있습니다. 각 객체는 num 속성에 숫자를, str 속성에 "함수가 실행되었습니다."라는 문자열을 가지고 있습니다.</li>
                                <li><i>함수 정의</i> → func라는 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받으며, 템플릿 리터럴을 사용하여 매개변수 값을 문자열로 결합하여 콘솔에 출력합니다.</li>
                                <li><i>함수 호출</i> → 두 번의 func 함수 호출을 합니다. 첫 번째 호출에서는 info[0].num과 info[0].str을 전달하고, 두 번째 호출에서는 info[1].num과 info[1].str을 전달합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w16" class="mt80">
                        <h4>16. 함수 유형 : 객체 안에 함수를 이용한 형태</h4>
                        <p>
                            객체 안에 함수를 이용한 형태의 함수 예제입니다.
                        </p>
<pre><code class="language-js">{
        const info = {
                num: 18,
                str: "함수가 실행되었습니다.",
                result: () => {
                        console.log(`${info.num}. ${info.str}`);
                }
        }
        info.result();

        // 18. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                객체 내부에 화살표 함수를 사용하여 함수를 정의하고 호출하는 예제입니다.
                            </p>
                            <ul class="list">
                                <li><i>info 객체 정의</i> → info 객체를 정의합니다. 이 객체는 세 개의 속성을 가지고 있습니다. num 속성은 18을, str 속성은 "함수가 실행되었습니다."라는 문자열을 가지고 있고, result 속성은 화살표 함수를 값으로 가지고 있습니다.</li>
                                <li><i>객체 내의 함수 호출</i> → info.result();를 호출하여 객체 내의 result 속성에 할당된 화살표 함수를 실행합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w17" class="mt80">
                        <h4>17. 함수 유형 : 객체 생성자 함수</h4>
                        <p>
                            객체 생성자 함수 예제입니다.
                        </p>
<pre><code class="language-js">{
        // 함수 정의
        function Func(num, str){
                this.num = num;
                this.str = str;
                this.result = () => {
                        console.log(`${this.num}. ${this.str}`);
                }
        }
        
        // 인스턴스 생성
        const info1 = new Func(19, "함수가 실행되었습니다.");
        const info2 = new Func(20, "함수가 실행되었습니다.");

        // 호출
        info1.result();
        info2.result();

        // 19. 함수가 실행되었습니다.
        // 20. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                생성자 함수를 사용하여 객체를 생성하고, 생성된 객체의 메서드를 호출하는 예제입니다.
                            </p>
                            <ul class="list">
                                <li><i>생성자 함수 Func 정의</i> → Func이라는 생성자 함수를 정의합니다. 이 생성자 함수는 두 개의 매개변수 num과 str을 받으며, 객체 내에 num 속성과 str 속성을 설정하고, result 메서드를 정의합니다. 이 메서드는 화살표 함수로 정의되어 있으며, 객체의 num 속성과 str 속성을 사용하여 문자열을 생성하고 콘솔에 출력합니다.</li>
                                <li><i>객체 인스턴스 생성</i> → Func 생성자 함수를 사용하여 info1과 info2 두 개의 객체 인스턴스를 생성합니다. 각각은 num과 str 매개변수를 받아 생성됩니다.</li>
                                <li><i>객체 메서드 호출</i> →  개의 객체 인스턴스 info1과 info2에서 result 메서드를 호출합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w18" class="mt80">
                        <h4>18. 함수 유형 : 프로토타입 함수</h4>
                        <p>
                            프로토타입 함수예제입니다.
                        </p>
<pre><code class="language-js">{
        // 함수 정의
        function Func(num, str){
                this.num = num;
                this.str = str;
        }

        // 메서드 추가
        Func.prototype.result = function(){
                console.log(`${this.num}. ${this.str}`);
        }

        // 인스턴스 생성
        const info1 = new Func(21, "함수가 실행되었습니다.");
        const info2 = new Func(22, "함수가 실행되었습니다.");

        // 호출
        info1.result();
        info2.result();

        // 21. 함수가 실행되었습니다.
        // 22. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                생성자 함수와 프로토타입을 사용하여 객체를 생성하고, 생성된 객체의 메서드를 호출하는 예제입니다.
                            </p>
                            <ul class="list">
                                <li><i>생성자 함수 Func 정의</i> → Func이라는 생성자 함수를 정의합니다. 이 생성자 함수는 두 개의 매개변수 num과 str을 받아 객체 내에 num 속성과 str 속성을 설정합니다.</li>
                                <li><i>프로토타입에 메서드 추가</i> → 생성자 함수 Func의 프로토타입에 result 메서드를 추가합니다. 이 메서드는 객체 내의 num 속성과 str 속성을 사용하여 문자열을 생성하고 콘솔에 출력합니다.</li>
                                <li><i>객체 인스턴스 생성</i> → Func 생성자 함수를 사용하여 info1과 info2 두 개의 객체 인스턴스를 생성합니다. 각각은 num과 str 매개변수를 받아 생성됩니다.</li>
                                <li><i>객체 메서드 호출:</i> → 두 개의 객체 인스턴스 info1과 info2에서 result 메서드를 호출합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w19" class="mt80">
                        <h4>19. 함수 유형 : 객체 리터럴 함수</h4>
                        <p>
                            객체 리터럴 함수 예제입니다. 
                        </p>
<pre><code class="language-js">{
        // 함수 정의
        function Func(num, str){
                this.num = num;
                this.str = str;
        }

        // 메서드 추가
        Func.prototype = {
                result1 : function(){
                        console.log(`${this.num}. ${this.str}`);
                },
                result2 : function(){
                        console.log(`${this.num}. ${this.str}`);
                }
        } 
        
        // 인스턴스 생성
        const info1 = new Func(23, "함수가 실행되었습니다.");
        const info2 = new Func(24, "함수가 실행되었습니다.");

        // 호출
        info1.result1();
        info2.result2();

        // 23. 함수가 실행되었습니다.
        // 24. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                생성자 함수와 프로토타입 객체를 사용하여 객체를 생성하고, 생성된 객체의 메서드를 호출하는 예제입니다. 이러한 방식은 프로토타입을 통해 메서드를 공유하는 객체 지향 프로그래밍의 한 예입니다.
                            </p>
                            <ul class="list">
                                <li><i>생성자 함수 Func 정의</i> → Func이라는 생성자 함수를 정의합니다. 이 생성자 함수는 두 개의 매개변수 num과 str을 받아 객체 내에 num 속성과 str 속성을 설정합니다.</li>
                                <li><i>프로토타입에 메서드 추가</i> → 생성자 함수 Func의 프로토타입을 새로운 객체로 덮어씁니다. 이 새로운 객체에는 result1 메서드와 result2 메서드가 정의되어 있습니다. 이 두 메서드는 객체 내의 num 속성과 str 속성을 사용하여 문자열을 생성하고 콘솔에 출력합니다.</li>
                                <li><i>객체 인스턴스 생성</i> → Func 생성자 함수를 사용하여 info1과 info2 두 개의 객체 인스턴스를 생성합니다. 각각은 num과 str 매개변수를 받아 생성됩니다.</li>
                                <li><i>객체 메서드 호출</i> → 두 개의 객체 인스턴스 info1과 info2에서 각각 result1 메서드와 result2 메서드를 호출합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w20" class="mt80">
                        <h4>20. 함수 : 즉시실행 함수</h4>
                        <p>
                            즉시 실행 함수(Immediately Invoked Function Expression, IIFE)는 JavaScript에서 자주 사용되는 패턴 중 하나로, 함수를 정의하자마자 즉시 실행하는 방식을 나타냅니다
                        </p>
<pre><code class="language-js">{
        // 01 즉시 실행 함수
        (function (){
                document.write("25. 함수가 실행되었습니다.");
        })();
        
        // 02 즉시 실행 함수(화살표 함수)
        (() => {
                document.write("26. 함수가 실행되었습니다.");
        })();

        // 25. 함수가 실행되었습니다.
        // 26. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이러한 IIFE 패턴은 변수와 함수를 현재 스코프로부터 격리하고 다른 코드와 충돌하지 않도록 하는 데 사용됩니다. 또한 전역 스코프에서 변수 누출을 방지하고 모듈 패턴과 같은 디자인 패턴에서도 자주 활용됩니다.
                            </p>
                            <ul class="list">
                                <li>01 → (function () { ... }): 선언적 함수를 정의하고 이를 괄호로 둘러싸서 함수를 표현합니다. ()로 함수를 즉시 실행합니다. 함수 내부의 코드는 "25. 함수가 실행되었습니다."라는 텍스트를 웹 페이지에 출력합니다.</li>
                                <li>02 → (() { ... }): 함수를 정의하고 이를 괄호로 둘러싸서 함수를 표현합니다. ()로 함수를 즉시 실행합니다. 함수 내부의 코드는 "26. 함수가 실행되었습니다."라는 텍스트를 웹 페이지에 출력합니다.</li>
                            </ul>
                        </div>

                        <h4>++ 스코프 ++</h4>
                        <div class="sampleBasic">
                            <p>
                                <i>스코프(Scope)는 변수와 함수의 유효 범위를 나타내는 개념으로</i>, 어떤 식별자(변수 또는 함수)가 어디서부터 어디까지 유효한지를 정의합니다. 스코프는 JavaScript와 같은 프로그래밍 언어에서 중요한 개념 중 하나입니다
                            </p>

                            <h5>전역 스코프 (Global Scope)</h5>
                            <ul class="list">
                                <li>전역 스코프는 코드의 어느 곳에서든 접근할 수 있는 최상위 스코프입니다.</li>
                                <li>전역 스코프에서 선언된 변수는 어디서든 사용할 수 있습니다.</li>
                                <li>전역 스코프는 어플리케이션 전체에서 유효합니다.</li>
                            </ul>

                            <h5>지역 스코프 (Local Scope)</h5>
                            <ul class="list">
                                <li>지역 스코프는 특정 블록 또는 함수 내부에서 선언된 변수의 유효 범위를 나타냅니다.</li>
                                <li>지역 스코프에서 선언된 변수는 해당 블록 내에서만 접근 가능합니다.</li>
                                <li>함수 내부에서 선언된 변수는 해당 함수의 지역 스코프에 속하며, 함수 외부에서는 접근할 수 없습니다.</li>
                            </ul>

                            <h5>블록 스코프 (Block Scope)</h5>
                            <ul class="list">
                                <li>블록 스코프는 중괄호 {}로 둘러싸인 코드 블록 내에서 선언된 변수의 유효 범위를 나타냅니다.</li>
                                <li>if, for, while과 같은 블록 문장 내에서 선언된 변수는 해당 블록 내에서만 유효합니다.</li>
                                <li>ES6에서 let과 const를 사용하여 블록 스코프 변수를 선언할 수 있습니다.</li>
                            </ul>

                            <h5>함수 스코프 (Function Scope)</h5>
                            <ul class="list">
                                <li>함수 스코프는 함수 내에서 선언된 변수의 유효 범위를 나타냅니다.</li>
                                <li>함수 내에서 선언된 변수는 해당 함수의 스코프에 속하며, 함수 외부에서는 접근할 수 없습니다.</li>
                                <li>함수 스코프는 전통적인 변수 선언에 사용되는 var 키워드로 생성됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w21" class="mt80">
                        <h4>21. 함수 : 파라미터 함수</h4>
                        <p>
                            JavaScript에서 함수를 정의할 때, 함수의 파라미터로 전달되는 값을 받아서 사용하는 함수입니다.
                            파라미터 함수를 사용하면 함수 내부에서 전달받은 값에 따라 다양한 처리를 할 수 있습니다.
                        </p>
<pre><code class="language-js">{
    // 01 선언적 함수
    function func(str = "27. 함수가 실행되었습니다."){
            document.write(str);
    }
    func();

    // 02 익명 함수(화살표 함수)
    const func1 = (str = "28. 함수가 실행되었습니다.") => {
            document.write(str);
    }
    func1();

    // 27. 함수가 실행되었습니다.
    // 28. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이러한 IIFE 패턴은 변수와 함수를 현재 스코프로부터 격리하고 다른 코드와 충돌하지 않도록 하는 데 사용됩니다. 또한 전역 스코프에서 변수 누출을 방지하고 모듈 패턴과 같은 디자인 패턴에서도 자주 활용됩니다.
                            </p>
                            <ul class="list">
                                <li>01 → function func(str = "27. 함수가 실행되었습니다.") { ... }: func라는 이름의 선언적 함수를 정의합니다. 이 함수는 str이라는 파라미터를 받고, 기본값으로 "27. 함수가 실행되었습니다."를 가집니다.</li>
                                <li>02 → const func1 = (str = "28. 함수가 실행되었습니다.") => { ... }: func1이라는 변수에 화살표 함수를 할당합니다. 이 함수도 str 파라미터를 받고, 기본값으로 "28. 함수가 실행되었습니다."를 가집니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w22" class="mt80">
                        <h4>22. 함수 : 재귀 함수</h4>
                        <p>
                            재귀 함수(Recursive Function)는 함수 내부에서 자기 자신을 호출하는 함수를 말합니다. 
                            즉, 함수가 자기 자신을 반복적으로 호출하면서 작업을 수행합니다.
                        </p>
<pre><code class="language-js">{
        // 01 반복문을 사용하기
        function func(num){
                for(let i=0; i&lt;num; i++){
                        document.write("29. 함수가 실행되었습니다.");
                }
        }
        func(10);

        // 02 재귀함수를 사용하기 
        function func1(num){
                if(num &lt; 1) return;

                document.write("30. 함수가 실행되었습니다.");
                func1(num - 1);    //재귀 호출
        }
        func1(10);
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                두 함수는 결과적으로 문자열을 여러 번 출력하는 역할을 수행하지만, 첫 번째 함수는 반복문을 사용하고 두 번째 함수는 재귀 호출을 사용하여 동일한 작업을 수행합니다. 재귀 함수의 경우 재귀 호출이 일어날 때마다 스택에 함수 호출이 추가되므로, 호출 횟수에 제한이 있을 수 있습니다.
                            </p>
                            <ul class="list">
                                <li>01 → func 함수는 num이라는 파라미터를 받습니다. 이 함수는 for 반복문을 사용하여 "29. 함수가 실행되었습니다."라는 문자열을 num의 값만큼 반복하여 출력합니다. 함수 호출 시 num 파라미터에 10을 전달하였으므로 문자열이 10번 출력됩니다.</li>
                                <li>02 → func1 함수는 num이라는 파라미터를 받습니다. 함수 내부에서 if 문을 사용하여 num이 0보다 작을 경우 함수를 종료하고 그렇지 않은 경우 "30. 함수가 실행되었습니다."를 출력하고 func1 함수를 자기 자신을 재귀적으로 호출합니다. 이렇게 호출되는 재귀 함수는 num 값이 0 미만이 될 때까지 반복되며 문자열이 출력됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w23" class="mt80">
                        <h4>23. 함수 : 콜백 함수</h4>
                        <p>
                            콜백 함수란 다른 함수로 전달되어 실행되는 함수입니다. 콜백 함수를 사용하면 비동기적인 작업을 수행하거나 함수 간의 협력을 할 때 유용하게 활용할 수 있습니다.
                        </p>
<pre><code class="language-js">{
        // 01 이벤트 처리시
        function func(){
                document.write("31. 함수가 실행되었습니다.");
        }
        btn.addEventListener("click", func);

        // 02 함수를 다른 함수의 인자로 전달
        function func1(){
                document.write("32. 함수가 실행되었습니다.");
        }
        function func2(callback){
                callback();
        }
        func2(func1);

        // 03 반복문으로 사용하는 경우
        function func3(num){
                document.write(num + ". 함수가 실행되었습니다.");
        }
        function func4(callback){
                for(let i=33; i&lt;=38; i++){
                        callback(i);
                }
        }
        func4(func3);
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이벤트 처리 및 함수를 다른 함수의 인자로 전달하는 예제를 보여줍니다.
                            </p>
                            <ul class="list">
                                <li>01 → func 함수는 클릭 이벤트가 발생했을 때 실행될 함수입니다. addEventListener 메서드를 사용하여 btn 요소에 "click" 이벤트 리스너를 등록합니다. 클릭 이벤트가 발생하면 func 함수가 실행되고, "31. 함수가 실행되었습니다."라는 메시지가 문서에 출력됩니다.</li>
                                <li>02 → func1 함수는 간단한 작업을 수행하는 함수입니다. func2 함수는 콜백 함수를 인자로 받아 해당 콜백 함수를 실행하는 함수입니다. func2(func1)를 호출하면 func1 함수가 func2 함수의 인자로 전달되어 실행됩니다. 결과적으로 "32. 함수가 실행되었습니다."라는 메시지가 문서에 출력됩니다.</li>
                                <li>03 → func3 함수는 매개변수 num을 받아서 해당 숫자와 함께 "33. 함수가 실행되었습니다."와 같이 메시지를 출력합니다. func4 함수는 콜백 함수를 인자로 받아 for 반복문을 사용하여 33부터 38까지의 숫자를 각각 콜백 함수에 전달하고 실행합니다. unc4(func3)를 호출하면 func3 함수가 func4 함수의 인자로 전달되어 여러 번 호출됩니다. 따라서 "33. 함수가 실행되었습니다."부터 "38. 함수가 실행되었습니다."까지의 메시지가 문서에 출력됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w24" class="mt80">
                        <h4>24. 함수 : 콜백 함수 : 동기/비동기</h4>
                        <p>
                            콜백 함수란 다른 함수로 전달되어 실행되는 함수입니다. 콜백 함수를 사용하면 비동기적인 작업을 수행하거나 함수 간의 협력을 할 때 유용하게 활용할 수 있습니다.
                        </p>
<pre><code class="language-js">{
        // 01 동기적인 함수 호출
        function func1( ){
                document.write("39. 함수가 실행되었습니다.");
        }
        function func2( ){
                document.write("40. 함수가 실행되었습니다.");
        }

        func1();
        func2();

        // 39. 함수가 실행되었습니다.
        // 40. 함수가 실행되었습니다.

        // 02 비동기적인 함수 호출
        function func3( ){
                setTimeout(( ) => {
                        document.write("41. 함수가 실행되었습니다.");
                }, 1000);  
        }
        function func4( ){
                document.write("42. 함수가 실행되었습니다.");
        }

        func3( );
        func4( );

        // 42. 함수가 실행되었습니다.
        // 41. 함수가 실행되었습니다.

        //03 콜백 함수와 비동기 호출
        function func5(callback){
                setTimeout(( ) => {
                        document.write("43. 함수가 실행되었습니다.");
                        callback( );
                }, 1000);
        }
        function func6( ){
                document.write("44. 함수가 실행되었습니다.");
        }

        func5(function(){
                func6( );
        });

        // 43. 함수가 실행되었습니다.
        // 44. 함수가 실행되었습니다.
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                동기적인 함수 호출과 비동기적인 함수 호출의 차이를 보여주며, 콜백 함수를 사용하여 비동기 작업을 처리하는 방법을 보여줍니다.
                            </p>
                            <ul class="list">
                                <li>01 → func1과 func2 함수는 동기적으로 호출되며, func1이 실행된 후 func2가 실행됩니다. 결과적으로 "39. 함수가 실행되었습니다."와 "40. 함수가 실행되었습니다."가 순서대로 출력됩니다.</li>
                                <li>02 → func3 함수는 setTimeout을 사용하여 1초(1000밀리초) 후에 실행될 함수를 정의합니다. func4 함수는 동기적으로 호출됩니다. func3는 비동기 작업이므로 "42. 함수가 실행되었습니다."가 먼저 출력되고, 1초 후에 "41. 함수가 실행되었습니다."가 출력됩니다.</li>
                                <li>03 → func5 함수는 setTimeout을 사용하여 1초 후에 실행될 함수를 정의합니다. 이때 콜백 함수 callback도 실행됩니다. func6 함수는 동기적으로 호출됩니다. func5를 호출할 때 콜백 함수를 전달하고, 콜백 함수 내부에서 func6 함수가 호출됩니다. 결과적으로 "43. 함수가 실행되었습니다."가 먼저 출력되고, 그 후 "44. 함수가 실행되었습니다."가 출력됩니다.</li>
                            </ul>
                        </div>

                        <h4>++ 동기방식과 비동기 방식++</h4>
                        <div class="sampleBasic">
                            <p>
                                동기(Synchronous)와 비동기(Asynchronous)는 프로그래밍에서 중요한 개념 중 하나입니다.
                                예를 들어, 웹 페이지에서 이미지를 다운로드하고 표시하는 작업을 생각해보세요. 
                                동기적인 방식으로 이미지를 다운로드하면 페이지가 이미지를 다운로드할 때까지 멈추고 사용자는 다른 작업을 수행하지 못합니다. 
                                반면에 비동기적인 방식을 사용하면 이미지 다운로드가 백그라운드에서 수행되므로 페이지는 다른 작업을 계속할 수 있습니다.
                            </p>
                            
                            <h5>동기(Synchronous)</h5>
                            <ul class="list">
                                <li>동기적인 작업은 순서대로 실행됩니다. 즉, 한 작업이 끝나야 다음 작업이 시작됩니다.</li>
                                <li>동기 코드는 위에서 아래로 순차적으로 진행되며, 한 작업이 끝나기를 기다려야 합니다.</li>
                                <li>동기 작업은 간단하게 이해하고 디버깅하기 쉽지만, 여러 작업을 동시에 처리하기 어렵습니다. 하나의 작업이 끝날 때까지 다른 작업을 수행하지 못합니다.</li>
                            </ul>

                            <h5>비동기 (Asynchronous):</h5>
                            <ul class="list">
                                <li>비동기적인 작업은 순서와 관계없이 동시에 여러 작업을 처리할 수 있습니다.</li>
                                <li>비동기 코드는 콜백 함수, 프로미스, async/await 등을 사용하여 작업이 완료될 때까지 대기하지 않고 다른 작업을 진행할 수 있습니다.</li>
                                <li>비동기 작업은 네트워크 요청, 파일 읽기, 타이머 등과 같은 작업에서 매우 유용하며, 애플리케이션의 반응성을 높일 수 있습니다.</li>
                            </ul>
                        </div>

                        <h4>++ 콜백지옥 ++</h4>
                        <div class="sampleBasic">
                            <p>
                                콜백 지옥(Callback Hell)은 비동기 JavaScript 코드에서 발생할 수 있는 가독성이 낮고 유지보수가 어려운 상황을 나타내는 용어입니다. 콜백 지옥은 콜백 함수를 중첩하여 사용할 때 발생하며, 특히 비동기 작업이 연속적으로 발생하는 경우에 빈번하게 발생합니다.
                            </p>
                        </div>
                        
<pre><code class="language-js">{
    function funcA(callback){
        setTimeout(( ) => {
            console.log("funcA가 실행되었습니다.");
            callback( );
        },1000);
    };
    function funcB(callback){
        setTimeout(( ) => {
            console.log("funcB가 실행되었습니다.");
            callback( );
        },1000);
    };
    function funcC(callback){
        setTimeout(( ) => {
            console.log("funcC가 실행되었습니다.");
            callback( );
        },1000);
    };
    function funcD(callback){
        setTimeout(( ) => {
            console.log("funcD가 실행되었습니다.");
        },1000);
    };

    funcA(function( ){
        funcB(function( ){
            funcC(function( ){
                funcD( );
            });
        });
    });    

    // funcA가 실행되었습니다.
    // funcB가 실행되었습니다.
    // funcC가 실행되었습니다.
    // funcD가 실행되었습니다.
}
</code></pre>
                    </div>

                    <div id="w25" class="mt80">
                        <h4>25. 비동기 방식 : 프로미스</h4>
                        <p>
                            JavaScript 프로미스(Promise)는 비동기 작업을 처리하고 관리하기 위한 객체입니다. 프로미스는 콜백 지옥(Callback Hell)과 같은 비동기 코드의 가독성 및 유지보수 문제를 해결하는 데 도움을 주는 중요한 개념 중 하나입니다.
                        </p>
<pre><code class="language-js">{
        // 비동기 작업 데이터
        let data = true;

        const func = new Promise((resolve, reject) => {
                if(data){
                        resolve("45. 함수가 실행되었습니다.");
                } else {
                        reject("45. 함수가 실행되지 않았습니다.");
                }
        });

        func
                .then(
                        result => document.write(result)
                )
                .catch(
                        error => document.write(error)
                )
}   
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이 코드는 data 변수의 값에 따라 성공 또는 실패를 나타내며, 이에 따라 적절한 메시지가 출력됩니다. 현재 data가 true로 설정되어 있으므로 성공 메시지인 "45. 함수가 실행되었습니다."가 출력될 것입니다.
                            </p>
                            <ul class="list">
                                <li>data 변수는 비동기 작업의 결과를 나타내는 플래그입니다. 이 예제에서는 true로 설정되어 있으므로 비동기 작업은 성공적으로 완료됩니다.</li>
                                <li>func이라는 이름의 Promise 객체를 생성합니다. 이 객체는 resolve와 reject 함수를 사용하여 상태를 결정합니다. data가 true인 경우 resolve를 호출하고 "45. 함수가 실행되었습니다."라는 문자열을 전달하여 성공 상태로 만듭니다. 그렇지 않으면 reject를 호출하고 "45. 함수가 실행되지 않았습니다."라는 에러 메시지를 전달하여 거부 상태로 만듭니다.</li>
                                <li>func 객체의 .then() 메서드는 프로미스가 이행될 때 실행됩니다. 이때 result 매개변수는 resolve에서 전달한 값인 "45. 함수가 실행되었습니다."를 받아와서 document.write()를 사용하여 결과를 출력합니다.</li>
                                <li>func 객체의 .catch() 메서드는 프로미스가 거부될 때 실행됩니다. 이때 error 매개변수는 reject에서 전달한 에러 메시지 "45. 함수가 실행되지 않았습니다."를 받아와서 document.write()를 사용하여 에러를 출력합니다.</li>
                            </ul>
                        </div>

                        <h4>++ 콜백지옥 소스 변경하기 ++</h4>
                        <div class="sampleBasic">
                            <p>
                                콜백 함수로 구현된 코드를 Promise를 사용하여 재구현하겠습니다.
                            </p>
                        </div>
                        
<pre><code class="language-js">{
        function funcA() {
                return new Promise((resolve) => {
                        setTimeout(() => {
                                console.log("funcA가 실행되었습니다.");
                                resolve();
                        }, 1000);
                });
        }
        
        function funcB() {
                return new Promise((resolve) => {
                        setTimeout(() => {
                                console.log("funcB가 실행되었습니다.");
                                resolve();
                        }, 1000);
                });
        }
        
        function funcC() {
                return new Promise((resolve) => {
                        setTimeout(() => {
                                console.log("funcC가 실행되었습니다.");
                                resolve();
                        }, 1000);
                });
        }
        
        function funcD() {
                return new Promise((resolve) => {
                        setTimeout(() => {
                                console.log("funcD가 실행되었습니다.");
                                resolve();
                        }, 1000);
                });
        }
        
        funcA()
                .then(funcB)
                .then(funcC)
                .then(funcD)
                .catch((error) => {
                    console.error(error);
                });  

        // funcA가 실행되었습니다.(1초뒤에)
        // funcB가 실행되었습니다.(1초뒤에)
        // funcC가 실행되었습니다.(1초뒤에)
        // funcD가 실행되었습니다.(1초뒤에)
}
</code></pre>
                    </div>

                    <div id="w26" class="mt80">
                        <h4>26. 비동기 방식 : async/await</h4>
                        <p>
                            async/await는 JavaScript에서 비동기 코드를 동기적으로 작성할 수 있도록 도와주는 문법입니다. 이것은 ECMAScript 2017(ES8)에서 도입되었으며, 프로미스 기반의 비동기 코드를 보다 가독성 좋게 작성할 수 있게 해줍니다.
                        </p>
<pre><code class="language-js">{
        // 01
        function func(){
                document.write("46. 함수가 실행되었습니다.");
        }
        func();

        // 02
        async function func2(){
                document.write("46. 함수가 실행되었습니다.");
        }
        func2();

        // 03
        async function func3(){
                const result = await fetch("https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json");
                const data = await result.json();
                console.log(data);
        }
        func3();

        // 04
        async function func4() {
                try {
                        const result = await fetch("https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json");
                        const data = await result.json();
                        console.log(data);
                } catch (error) {
                        console.error(error);
                }
        }
        func4();
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                이 코드는 async/await를 사용하여 비동기 작업을 간결하고 가독성 있게 처리하고 있으며, 에러 처리도 함께 다루고 있습니다.
                            </p>
                            <ul class="list">
                                <li>01 → func() 함수: 이 함수는 일반적인 동기 함수입니다. 함수를 호출하면 즉시 실행되고 "46. 함수가 실행되었습니다."를 문서에 출력합니다.</li>
                                <li>02 → async 키워드가 함수 앞에 붙어 있습니다. 이것은 비동기 함수를 나타냅니다. 함수 내부에서도 "46. 함수가 실행되었습니다."를 출력하고 있지만, 함수 호출이 비동기적으로 처리됩니다. 함수가 호출되면 즉시 반환되고 나중에 실행됩니다.</li>
                                <li>03 → 이 함수는 비동기 함수로, fetch() 함수를 사용하여 원격 URL에서 데이터를 가져옵니다. fetch()로부터 받은 결과를 await를 사용하여 기다린 후에 result.json()을 사용하여 JSON 데이터로 변환합니다. JSON 데이터를 콘솔에 출력합니다.</li>
                                <li>04 → 이 함수는 func3()와 유사하지만 에러 처리가 추가되어 있습니다. try...catch 블록을 사용하여 비동기 작업 중 발생할 수 있는 에러를 처리합니다. 비동기 작업이 실패하면 catch 블록이 실행되고 에러 메시지가 콘솔에 출력됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w27" class="mt80">
                        <h4>27. 함수 : 중첩 함수</h4>
                        <p>
                            중첩 함수(nested function)는 하나의 함수 내부에서 또 다른 함수를 정의하는 것을 의미합니다. 이렇게 정의된 내부 함수는 외부 함수의 스코프(scope)에 접근할 수 있으며, 주로 외부 함수 내의 변수나 매개변수에 접근하여 작업을 수행합니다. 내부 함수라고 불리기도 합니다. 
                        </p>
<pre><code class="language-js">{
    function outer() {
            let outerVariable = "47. 함수가 실행되었습니다.";
        
            function inner() {
                    var innerVariable = "48. 함수가 실행되었습니다.";
                    console.log("innerVariable:", innerVariable); // 내부 변수 출력
                    console.log("outerVariable:", outerVariable); // 외부 변수 출력
            }
    
            return inner;
    }
    
    var innerFunction = outer(); // 외부 함수 호출 및 내부 함수 반환
    innerFunction(); // 내부 함수 호출       
}
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                내부 함수를 사용하면 코드의 가독성을 향상시키고 재사용성을 증가시킬 수 있습니다. 또한 클로저를 형성하는 데 사용될 수 있으며, 비동기 작업, 콜백 함수, 이벤트 처리 등 다양한 상황에서 유용하게 활용됩니다.
                            </p>
                            <ul class="list">
                                <li><i>outer 함수 정의</i> → outer 함수는 내부 함수 inner를 정의하고, outerVariable과 innerVariable이라는 두 개의 지역 변수를 가지고 있습니다. inner 함수는 outer 함수 내에서 정의되어 있으며, 내부 변수에 접근할 수 있습니다.</li>
                                <li><i>inner 함수 반환</i> → outer 함수는 inner 함수를 반환합니다. 이것은 inner 함수가 외부로 노출되고 외부에서 호출 가능해진다는 의미입니다.</li>
                                <li><i>innerFunction 변수에 outer 함수 호출 결과 할당</i> → innerFunction 변수에 outer()를 호출한 결과, 즉 inner 함수가 할당됩니다. 이때 outer 함수가 실행되고 inner 함수가 반환됩니다.</li>
                                <li><i>innerFunction 함수 호출</i> → innerFunction 변수에 할당된 함수인 inner 함수를 호출합니다. 이때, inner 함수 내부에서는 innerVariable과 outerVariable 변수에 접근하고, 해당 변수들의 값을 콘솔에 출력합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w28" class="mt80">
                        <h4>28. 함수 : 클로저</h4>
                        <p>
                            클로저(Closure)는 프로그래밍 언어에서 중요한 개념 중 하나로, 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical Environment) 사이의 특별한 관계를 나타냅니다. 클로저는 함수 내부에서 선언한 변수가 함수가 외부로 리턴된 후에도 그 값을 기억하고 접근할 수 있는 메커니즘을 의미합니다. 
                        </p>
<pre><code class="language-js">{
        function outer() {
                var count = 0;
            
                function inner() {
                        count++;
                        console.log(count + ". 함수가 실행되었습니다.");
                }
            
                return inner;
        }
        
        var closure = outer(); // outer 함수를 호출하고 inner 함수를 반환
        closure(); 
        closure(); 

        // 1. 함수가 실행되었습니다.
        // 2. 함수가 실행되었습니다.
}
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                주요 포인트는 inner 함수가 outer 함수 내에서 정의되었으므로, inner 함수는 outer 함수의 스코프에 접근할 수 있고, 클로저로서 외부 변수인 count에도 접근할 수 있다는 것입니다. 이렇게 inner 함수가 외부 변수와 함께 외부 함수의 스코프를 기억하고 유지하는 것이 클로저의 핵심 개념입니다.
                            </p>
                            <ul class="list">
                                <li><i>outer 함수 정의</i> → outer 함수는 내부 함수 inner를 정의하고, count라는 지역 변수를 가지고 있습니다. inner 함수는 outer 함수 내에서 정의되어 있으며, count 변수를 사용하여 실행 횟수를 증가시키고 메시지를 출력합니다.</li>
                                <li><i>inner 함수 반환</i> → outer 함수는 inner 함수를 반환합니다. 이것은 inner 함수가 외부로 노출되고 외부에서 호출 가능해진다는 의미입니다.</li>
                                <li><i>closure 변수에 outer 함수 호출 결과 할당</i> → closure 변수에 outer()를 호출한 결과, 즉 inner 함수가 할당됩니다. 이때 outer 함수가 실행되고 inner 함수가 반환됩니다.</li>
                                <li><i>closure 함수 호출</i> → closure 변수에 할당된 함수인 inner 함수를 두 번 호출합니다. 각 호출 시에 count 변수가 증가되고, 실행 횟수와 함께 "함수가 실행되었습니다." 메시지가 콘솔에 출력됩니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w29" class="mt80">
                        <h4>29. 클래스 : 기본</h4>
                        <p>
                            JavaScript에서 클래스(Class)는 객체 지향 프로그래밍(OOP)의 핵심 개념 중 하나로, 객체를 생성하기 위한 템플릿 역할을 합니다. 클래스를 사용하여 객체를 생성하고, 객체의 속성(멤버 변수)과 메서드(멤버 함수)를 정의하고 관리할 수 있습니다
                        </p>
<pre><code class="language-js">{
        class Study {
            constructor(num, text){
                this.num = num;
                this.text = text;
            }
        
            result(){
                document.write(this.num + ". 클래스가 " + this.text);
            }
        }

        // 객체 생성
        const info1 = new Study("1", "실행되었습니다.");
        const info2 = new Study("2", "실행되었습니다.");
        
        // 호출
        info1.result();
        info2.result();
}
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                JavaScript 클래스를 사용하여 객체를 생성하고, 객체의 메서드를 호출하여 브라우저 화면에 정보를 출력하는 예제입니다.
                            </p>
                            <ul class="list">
                                <li><i>Study 클래스 정의</i> → Study 클래스는 constructor 메서드를 가지고 있습니다. 이 생성자 메서드는 num과 text 두 개의 매개변수를 받아 객체의 속성으로 설정합니다. result 메서드는 객체의 속성인 num과 text를 사용하여 결과를 document.write를 사용하여 출력합니다.</li>
                                <li><i>info1과 info2 객체 생성</i> → info1과 info2는 Study 클래스를 사용하여 객체를 생성합니다. 각각의 객체는 생성자 메서드에 전달된 매개변수 값을 가지게 됩니다.</li>
                                <li><i>객체 메서드 호출</i> → result 메서드를 호출하여 객체의 정보를 출력합니다. info1.result()는 "1. 클래스가 실행되었습니다."를 출력하고, info2.result()는 "2. 클래스가 실행되었습니다."를 출력합니다.</li>
                            </ul>
                        </div>
                    </div>

                    <div id="w30" class="mt80">
                        <h4>30. 클래스 : 상속</h4>
                        <p>
                            JavaScript에서 클래스(Class)는 객체 지향 프로그래밍(OOP)의 핵심 개념 중 하나로, 객체를 생성하기 위한 템플릿 역할을 합니다. 클래스를 사용하여 객체를 생성하고, 객체의 속성(멤버 변수)과 메서드(멤버 함수)를 정의하고 관리할 수 있습니다
                        </p>
<pre><code class="language-js">{
        class Study1 {
                constructor(num, text){
                        this.num = num;
                        this.text = text;
                }
            
                result1(){
                        document.write(this.num + ". 클래스가 " + this.text);
                }
        }
        
        class Study2 extends Study1 {
                constructor(num, text, active){
                        super(num, text);
                        this.active = active;
                }
                result2(){
                        document.write(this.num + ". " + this.text + "가 " + this.active + "되었습니다");
                }
        }
        
        // 객체 생성
        const info1 = new Study1("3", "실행되었습니다.");
        const info2 = new Study2("4", "클래스", "실행");

        
        // 호출
        info1.result1();
        info2.result2();
}
</code></pre>
                        <div class="sampleBasic">
                            <p class="sampleIcon">
                                클래스를 사용하여 객체를 생성하고, 상속을 활용하여 두 개의 클래스를 정의하고 객체를 생성한 후에 메서드를 호출하는 예제입니다
                            </p>
                            <ul class="list">
                                <li><i>Study1 클래스 정의</i> → Study1 클래스는 constructor 메서드를 가지고 있으며, 생성자 메서드는 num과 text 두 개의 매개변수를 받아 객체의 속성으로 설정합니다. result1 메서드는 객체의 속성인 num과 text를 사용하여 결과를 document.write를 사용하여 출력합니다.</li>
                                <li><i>Study2 클래스 정의(상속)</i> → Study2 클래스는 extends 키워드를 사용하여 Study1 클래스를 상속합니다. 이렇게 하면 Study2 클래스는 Study1 클래스의 속성과 메서드를 상속받습니다. constructor 메서드에서 super(num, text)를 호출하여 부모 클래스인 Study1의 생성자를 실행하고, active 속성을 추가로 설정합니다. result2 메서드는 Study2 클래스에만 존재하며, 객체의 속성들을 사용하여 결과를 출력합니다.</li>
                                <li><i>객체 생성</i> → Study1과 Study2 클래스를 사용하여 각각 info1과 info2 객체를 생성합니다.</li>
                                <li><i>메서드 호출</i> → result1 메서드와 result2 메서드를 호출하여 객체의 정보를 출력합니다.</li>
                            </ul>
                        </div>
                    </div>






                    <hr>

                    <div class="right_refer">
                        <a href="https://port2023-next.netlify.app/" target="_blank" class="sampleBtn">완성 화면</a>
                        <a href="https://github.com/webstoryboy" target="_blank" class="sampleBtn">소스 보기</a>
                        <a href="https://www.youtube.com/playlist?list=PL4UVBBIc6giLabEb4ygOmKDWCnsSKq2uP" target="_blank" class="sampleBtn">영상 보기</a>
                    </div>

                    <h3>예제 목록</h3>
                    <div class="refer5_wrap">
                        <ul class="refer5">
                            <li><a href="https://webstoryboy.co.kr/1924">1. 포트폴리오 사이트 만들기 : Vite-Site : 셋팅하기</a></li>
                        </ul>
                    </div>
                </div>
                <!-- //blog__contents -->

                <aside class="blog__aside">
                    <button class="blog__aside__btn"><span></span></button>
                    <div class="blog__aside__chapter">
                    </div>
                </aside>
            </div>
        </section>
        <!-- //blog -->
    </main>
    <!-- //main -->

    <footer id="footer">

    </footer>
    <!-- //footer -->

    <script src="../../assets/js/jquery-3.6.0.js"></script>
    <script src="../../assets/js/jquery-ui.js"></script>
    <script src="../../assets/js/highlight.min.js"></script>
    <script src="../../assets/js/webs.js"></script>
    <script>
        

        // 05. 함수 : 매개변수 + 리턴값 함수
        {
            function func(x){
                return x;
            }
            const num = func(100);
            console.log(num);

            const func1 = function(x){
                return x;
            }
            const num1 = func1(100);
            console.log(num1);
   
        }
    </script>
</body>
</html>

